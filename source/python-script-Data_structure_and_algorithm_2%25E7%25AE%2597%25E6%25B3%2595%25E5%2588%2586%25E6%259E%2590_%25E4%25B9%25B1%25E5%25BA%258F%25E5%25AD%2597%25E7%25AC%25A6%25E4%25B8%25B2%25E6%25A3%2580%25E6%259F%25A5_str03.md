---
title: python script Data structure and algorithm 2%25E7%25AE%2597%25E6%25B3%2595%25E5%2588%2586%25E6%259E%2590 %25E4%25B9%25B1%25E5%25BA%258F%25E5%25AD%2597%25E7%25AC%25A6%25E4%25B8%25B2%25E6%25A3%2580%25E6%259F%25A5 str03 (snippet)
date: 2020-03-03
tags: ["python"]
---
Python script 'Data structure and algorithm 2%25E7%25AE%2597%25E6%25B3%2595%25E5%2588%2586%25E6%259E%2590 %25E4%25B9%25B1%25E5%25BA%258F%25E5%25AD%2597%25E7%25AC%25A6%25E4%25B8%25B2%25E6%25A3%2580%25E6%259F%25A5 str03'


## python Data structure and algorithm 2%25E7%25AE%2597%25E6%25B3%2595%25E5%2588%2586%25E6%259E%2590 %25E4%25B9%25B1%25E5%25BA%258F%25E5%25AD%2597%25E7%25AC%25A6%25E4%25B8%25B2%25E6%25A3%2580%25E6%259F%25A5 str03

Python mysql example: Data structure and algorithm 2%25E7%25AE%2597%25E6%25B3%2595%25E5%2588%2586%25E6%259E%2590 %25E4%25B9%25B1%25E5%25BA%258F%25E5%25AD%2597%25E7%25AC%25A6%25E4%25B8%25B2%25E6%25A3%2580%25E6%259F%25A5 str03

```python
"""
穷举法

解决这类问题的强力方法是穷举所有可能性。
对于乱序检测，我们可以生成 s1 的所有乱序字符串列表，然后查看是不是有 s2。
这种方法有一点困难。当 s1 生成所有可能的字符串时，第一个位置有 n 种可能，第二个位置有 n-1 种，第三个位置有 n-3 种，等等。
总数为 n∗(n−1)∗(n−2)∗...∗3∗2∗1n∗(n−1)∗(n−2)∗...∗3∗2∗1， 即 n!。
虽然一些字符串可能是重复的，程序也不可能提前知道这样，所以他仍然会生成 n! 个字符串。

事实证明，n! 比 n^2 增长还快，
事实上，如果 s1 有 20个字符长，则将有 20! = 2,432,902,008,176,640,000 个字符串产生。
如果我们每秒处理一种可能字符串，那么需要 77,146,816,596 年才能过完整个列表。所以这不是很好的解决方案。
"""
'''
@Time    : 2018/2/4 下午2:49
@Author  : scrappy_zhang
@File    : str03.py
'''

```

## Python links

- Learn Python: https://pythonbasics.org/
- Python Tutorial: https://pythonspot.com
